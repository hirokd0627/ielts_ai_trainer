import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:ielts_ai_trainer/features/writing/domain/writing_answer.dart';
import 'package:ielts_ai_trainer/features/writing/domain/writing_answer_repository.dart';
import 'package:ielts_ai_trainer/shared/enums/test_task.dart';
import 'package:ielts_ai_trainer/shared/enums/writing_prompt_type.dart';

/// Controller for WritingAnswerInputScreen.
class WritingAnswerInputController extends ChangeNotifier {
  /// Repository for user answers related to writing tasks.
  final WritingAnswerRepository _repo;

  /// The start time used to calculate the elapsed duration.
  late DateTime _startTime;

  /// Timer used to track the elapsed duration.
  late Timer _timer;

  /// Elapsed time since the timer started.
  Duration _elapsed = const Duration();

  /// The prompt text generated by the question generator screen.
  final String _promptText;

  /// The topics used to generate the prompt.
  final List<String> _topics;

  /// The task type.
  final TestTask _testTask;

  /// The prompt type used to generate the prompt.
  final WritingPromptType _promptType;

  /// The answer text the user entered.
  String _answerText = '';

  WritingAnswerInputController({
    required WritingAnswerRepository writingAnswerRepository,
    required TestTask testTask,
    required String promptText,
    required List<String> topics,
    required WritingPromptType promptType,
  }) : _repo = writingAnswerRepository,
       _testTask = testTask,
       _promptText = promptText,
       _topics = topics,
       _promptType = promptType;

  WritingPromptType? get promptType => _promptType;

  String get answerText => _answerText;

  Duration get elapsed => _elapsed;

  /// Whether the submit button is enabled.
  bool get isSubmitButtonEnabled {
    // Submit button is active only if answer text is not empty.
    return _answerText.isNotEmpty;
  }

  /// Returns the elapsed duration since the timer started.
  Duration get _elapsedDuration {
    final msec =
        DateTime.now().millisecondsSinceEpoch -
        _startTime.millisecondsSinceEpoch;
    return Duration(milliseconds: msec);
  }

  /// Returns the current word count and the recommended word count.
  String get elapsedAsText {
    final m = _elapsed.inMinutes.toString().padLeft(2, '0');
    final s = (_elapsed.inSeconds % 60).toString().padLeft(2, '0');
    return "$m:$s";
  }

  /// Returns the current entered word count and recommended word count.
  String getWordCountAsText(TestTask testTask) {
    final recommendedWordCount = testTask == TestTask.writingTask1 ? 150 : 250;
    // Consider apostrophes as part of a word (e.g., "it's" counts as one word).
    final length = RegExp(r"\b[\w']+\b").allMatches(_answerText).length;
    return "$length / $recommendedWordCount";
  }

  set answerText(String value) {
    _answerText = value.trim();

    notifyListeners();
  }

  /// Starts the duration timer.
  void startTimer() {
    _startTime = DateTime.now();
    _timer = Timer.periodic(const Duration(seconds: 1), (_) {
      _elapsed = _elapsedDuration;
      notifyListeners();
    });
  }

  /// Stops the duration timer.
  void cancelTimer() {
    _timer.cancel();
  }

  /// Saves the user's answer.
  Future<int> saveUserAnswer() async {
    final now = DateTime.now();

    final answer = WritingAnswer(
      testTask: _testTask,
      createdAt: now,
      promptText: _promptText,
      answerText: _answerText,
      isGraded: false,
      duration: _elapsedDuration.inSeconds,
      topics: _topics,
      promptType: _promptType,
      updatedAt: now,
    );

    return await _repo.saveUserAnswerWriting(answer);
  }
}
