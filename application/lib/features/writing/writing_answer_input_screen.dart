import 'dart:io';

import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:ielts_ai_trainer/app/router_extra.dart';
import 'package:ielts_ai_trainer/app/theme/app_colors.dart';
import 'package:ielts_ai_trainer/app/theme/app_styles.dart';
import 'package:ielts_ai_trainer/features/writing/domain/writing_answer_repository.dart';
import 'package:ielts_ai_trainer/features/writing/domain/writing_prompt_vo.dart';
import 'package:ielts_ai_trainer/features/writing/writing_answer_input_controller.dart';
import 'package:ielts_ai_trainer/features/writing/writing_diagram_service.dart';
import 'package:ielts_ai_trainer/features/writing/writing_routes.dart';
import 'package:ielts_ai_trainer/shared/database/app_database.dart';
import 'package:ielts_ai_trainer/shared/enums/test_task.dart';
import 'package:ielts_ai_trainer/shared/enums/writing_prompt_type.dart';
import 'package:ielts_ai_trainer/shared/utils/dialog.dart';
import 'package:ielts_ai_trainer/shared/views/base_screen_scaffold.dart';
import 'package:ielts_ai_trainer/shared/views/texts.dart';
import 'package:provider/provider.dart';

/// Writing Answer Input Screen.
class WritingAnswerInputScreen extends StatefulWidget {
  /// The prompt components generated by the question generator screen.
  final WritingPromptVo writingPrompt;

  /// The topics used to generate the prompt.
  final List<String> topics;

  /// The task type.
  final TestTask testTask;

  /// The prompt type used to generate the prompt.
  final WritingPromptType promptType;

  const WritingAnswerInputScreen({
    super.key,
    required this.writingPrompt,
    required this.topics,
    required this.testTask,
    required this.promptType,
  });

  @override
  State<WritingAnswerInputScreen> createState() =>
      _WritingAnswerInputScreenState();
}

/// State for WritingAnswerInputScreen.
class _WritingAnswerInputScreenState extends State<WritingAnswerInputScreen> {
  late final WritingAnswerInputController _ctrl;
  final WritingDiagramService _diagramSrv = WritingDiagramService();

  /// The diagram image file path.
  String _diagramPath = '';

  /// Returns the screen title based on the task type.
  String get _screenTitle {
    return widget.testTask == TestTask.writingTask1
        ? 'Writing Task 1'
        : 'Writing Task 2';
  }

  @override
  void initState() {
    super.initState();

    _ctrl = WritingAnswerInputController(
      writingAnswerRepository: WritingAnswerRepository(
        context.read<AppDatabase>(),
      ),
      testTask: widget.testTask,
      writingPrompt: widget.writingPrompt,
      topics: widget.topics,
      promptType: widget.promptType,
    );

    _ctrl.startTimer();

    if (widget.testTask == TestTask.writingTask1) {
      _loadImage();
    }
  }

  @override
  void dispose() {
    _ctrl.cancelTimer();
    super.dispose();
  }

  /// Called when the answer text changes.
  void _onChangedAnswerText(String value) {
    _ctrl.answerText = value;
  }

  /// Loads and shows diagram image.
  Future<void> _loadImage() async {
    final path = await _diagramSrv.getTempFilePath(
      widget.writingPrompt.diagramUuid!,
    );
    setState(() {
      _diagramPath = path;
    });
  }

  /// Called when the submit button is pressed.
  void _onPressedSubmit() async {
    // Confirm whether to submit the answer.
    final confirmed = await showSubmitAnswerDialog(context);
    if (confirmed == null || !confirmed) {
      return;
    }

    // Save the answer
    int id;
    try {
      id = await _ctrl.saveUserAnswer();
    } catch (e, stackTrace) {
      if (!mounted) {
        // avoid context across async gaps.
        return;
      }
      showAlertDialog(context, e.toString(), stackTrace.toString());
      return;
    }

    if (!mounted) {
      // avoid context across async gaps.
      return;
    }

    // Navigates to the result screen.
    final loc = widget.testTask == TestTask.writingTask1
        ? writingTask1ResultScreenRoutePath
        : writingTask2ResultScreenRoutePath;
    context.go(loc, extra: RouterExtra({'id': id}));
  }

  /// Called when the cancel button is pressed.
  void _onPressedCancel() async {
    // Confirm whether to stop practicing.
    final confirmed = await showQuitPracticeDialog(context);
    if (confirmed == null || !confirmed) {
      return;
    }

    if (!mounted) {
      // If state has been destroyed, context cannot be used, so return
      return;
    }

    // Navigates to the question generator screen.
    final extra = RouterExtra({
      'writingPrompt': widget.writingPrompt,
      'topics': widget.topics,
      'promptType': widget.promptType,
    });
    if (widget.testTask == TestTask.writingTask1) {
      context.go(writingTask1QuestionGeneratorScreenRoutePath, extra: extra);
    } else if (widget.testTask == TestTask.writingTask2) {
      context.go(writingTask2QuestionGeneratorScreenRoutePath, extra: extra);
    }
  }

  @override
  Widget build(BuildContext context) {
    return BaseScreenScaffold(
      showHeader: false,
      body: AnimatedBuilder(
        animation: _ctrl,
        builder: (context, _) {
          return SingleChildScrollView(
            child: Padding(
              padding: EdgeInsets.symmetric(
                horizontal: AppStyles.screenPadding,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      // Screen title
                      ScreenTitleText(_screenTitle),
                      // Elapsed time
                      Text(_ctrl.elapsedAsText),
                    ],
                  ),
                  SizedBox(height: 20),

                  // Prompt
                  if (widget.testTask == TestTask.writingTask1) ...[
                    Text(widget.writingPrompt.taskContext),
                    if (_diagramPath.isNotEmpty)
                      Center(child: Image.file(File(_diagramPath), width: 500)),
                    Text(widget.writingPrompt.taskInstruction),
                  ],
                  if (widget.testTask == TestTask.writingTask2) ...[
                    Text(widget.writingPrompt.promptText),
                  ],
                  SizedBox(height: 20),
                  // Answer Input field
                  TextField(
                    minLines: 5, // always show at least 5 lines
                    maxLines: null, // expands automatically
                    keyboardType: TextInputType.multiline,
                    decoration: InputDecoration(
                      // border: OutlineInputBorder(),
                      focusedBorder: OutlineInputBorder(
                        borderSide: BorderSide(
                          color: AppColors.focusColor,
                          width: 1,
                        ),
                      ),
                      enabledBorder: OutlineInputBorder(
                        borderSide: BorderSide(
                          color: AppColors.borderColor,
                          width: 1,
                        ),
                      ),
                      hintText: 'Type your answer...',
                      hintStyle: TextStyle(
                        color: AppColors.placeholderTextColor,
                        fontWeight: FontWeight.w400,
                      ),
                    ),
                    style: TextStyle(color: AppColors.textColor),
                    onChanged: _onChangedAnswerText,
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Padding(
                        padding: const EdgeInsets.only(top: 8),
                        child: Text(_ctrl.getWordCountAsText(widget.testTask)),
                      ),
                      Padding(
                        padding: const EdgeInsets.only(top: 20),
                        child: Row(
                          children: [
                            TextButton(
                              onPressed: _onPressedCancel,
                              style: ButtonStyle(
                                backgroundColor: WidgetStatePropertyAll(
                                  AppColors.chipBackground,
                                ),
                              ),
                              child: const Text('Quit'),
                            ),
                            SizedBox(width: 12),
                            FilledButton(
                              onPressed: _ctrl.isSubmitButtonEnabled
                                  ? _onPressedSubmit
                                  : null,
                              child: const Text('Submit'),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                  SizedBox(height: AppStyles.screenBottomPadding),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}
